## SerialLin补充
* jtraj的简化写法：q = p560.jtraj(T1, T2, t)，不用先反解q1，q2.
* qplot(t,q)绘制所有关节角度随时间的变化情况
* 对于T = p560.fkine(q)，p = transl(T)返回三维笛卡尔坐标向量，plot(p(:,1),p(:,2))绘制xy平面轨迹。
* 绘制横滚俯仰偏航角随时间的变化：plot(t, tr2rpy(T))
  (注意关节角度随时间变化，笛卡尔坐标随时间变化，平面轨迹与偏航角随时间变化之间的区别)
* **工具箱确定DH参数的另一方法**：
  1.把从基座到顶端的平移和旋转序列写入一个字符串
  eg：s = 'Tz(L1) Rz(q1) Ry(q2) Ty(L2) Tz(L3) Ry(q3) Tx(L6) Ty(L4) Tz(L5) Rz(q4) Ry(q5) Rz(q6)'

  2.用DHFactor创建一个DHFactor对象
  eg：dh = DHFactor(s);

  3.cmd = dh.command('puma')创建机器人，eval(cmd)创建SerialLink对象。
* **利用机器人绘图**：
  1.先指定途径点path = [1 0 1; 1 0 0;...]，其中z > 1表示抬起，z = 0表示放下。
.
  2.路径绘制：plot3(path(:,1), path(:,2), path(:,3), 'color', 'k', 'LineWidth', 2)
.
  3.转换为连续路径:p = mstraj(path, [0.5 0.5 0.3], [], [2 2 2], 0.02, 0.2);
.
  4.转化为笛卡尔位姿: Tp = transl(0.1 * p)，乘以0.1表示坐标值缩小为原来的0.1.
.
  5.指定工作空间：Tp = homtrans(transl(0.4, 0, 0), Tp)，homtrans表示Tp的每个位姿都乘以第一个参数
.
  6.工具轴翻转：p560.tool = trotx(pi);
.
  7.应用逆运动学求解出q

* **步行机器人绘制**：
```
s = 'Rz(q1).Rx(q2).Ty(L1).Rx(q3).Tz(L2)';
dh = DHFactor(s)
L1 = 0.1; L2 = 0.1;
leg = eval(dh.command('leg'))
leg.plot([0,0,0], 'nobase', 'noshadow')
set(gca, 'Zdir', 'reverse');//反转z轴

xf = 50; xb = -xf; y = 50; zu = 20; zd = 50;
path = [xf y zd; xb y zd; xb y zu; xf y zu; xf y zd] * 1e-3;
p = mstraj(path, [], [0, 3, 0.25, 0.5, 0.25]', path(1,:), 0.01, 0);
qcycle = leg.ikine(transl(p), [], [1 1 1 0 0 0]);

W = 0.1;L = 0.2;
legs(1) = SerialLink(leg, 'name', 'leg1');
legs(2) = SerialLink(leg, 'name', 'leg2', 'base', transl(-L, 0, 0));
legs(3) = SerialLink(leg, 'name', 'leg3', 'base', transl(-L, W, 0)*trotz(pi));
legs(4) = SerialLink(leg, 'name', 'leg4', 'base', transl(0, -W, 0)*trotz(pi));

k = 1;
while 1
    q = qleg(p,:);
    legs(1).plot(gait(qcycle, k, 0, 0));
    legs(2).plot(gait(qcycle, k, 100, 0));
    legs(3).plot(gait(qcycle, k, 200, 1));
    legs(4).plot(gait(qcycle, k, 300, 1));
    drawnow
    k = k+1;
end
```
其中gait(q, k, ph, flip)**返回q的第k + ph个元素，flip取1表示对运动符号取反。

## 雅可比矩阵深入
对T关于关节坐标q求导，有：

其中右边的1*3向量表示平移位移，对左上角的3 * 3矩阵，可以推导出末端执行器角速度和关节速度之间的关系：

（在matlab中有w = vex(dRdq1 * R')

对正运动学函数求导，可得：V = J(q)q'，其中V是六维向量，包含平移速度和旋转速度分量，J(q)是雅可比矩阵，在matlab中用p560.jacob0(位姿)计算。

**空间速度转换**：坐标系之间的速度转换为^B^V = ^B^J~A~^A^V
* 在matlab中用tr2jac(T)求出对应变化的雅可比矩阵。从而若已知A的空间速度可得B的空间速度。
* 若要求对于末端坐标系的雅可比矩阵，采用jacobn
* 利用rpy2jac将横滚俯仰偏航角速度映射到空间角速度，也有eul2jac函数。
* 如果雅可比矩阵不满秩（行列式等于0），用伪逆pinv代替逆
* 对于过驱动机器人，使用零空间控制提供额外约束：**q' = J(q)^+^V + NN^+^q'**(分别表示末端执行器运动和零空间运动，零空间运动不影响末端执行器运动)
```
qd_ns = [0 0 0 0 -0.1 0 0 0]';//指定关节5的关节速度
qp = N * pinv(N) * qd_ns;//映射到零空间
qp = qp/qp(5) * qd_ns(5);//进行校正
```

**力旋量转换**
对于力旋量g = (f~x~, f~y~, f~z~, m~x~, m~y~, m~z~)，有^A^g = (^B^J~A~)^T^ * ^B^g
```
eg:在世界坐标系y轴上作用一20N的力
tau = p560.jacob0(qn)' * [0 20 0 0 0 0]';
```

## 运动规划初步
运动规划是一个寻找开始状态到目标状态的机器人运动问题。
**位形空间**：又称C空间，C空间的每个点对应机器人的唯一位形q(θ1，θ2...θn)，将用于驱动机器人的控制输入写成m维向量，用x表示机器人状态，则有机器人运动方程x' = f(x, u)
或者可写成积分形式：

**运动规划的变种**：
1.路径规划：在初始位形和目标位形之间寻找一条无碰撞路径q(s)，不涉及动力学，运动持续时间。

2.控制输入m小于自由度n，则机器人无法跟踪多条路径。

3.在线与离线：在线指障碍物出现，消失或不可预测移动所需要的快速算法，若环境是静态的，选较慢的离线算法。

4.有无障碍物/时间最优..

**运动规划算法性质**:
1.多查询规划:在不变的环境中求解许多运动规划问题,可以构建表示C自由空间的数据结构.

2.随时规划:找到第一个解后继续寻找更好解的规划算法,可以随时停止

3.完整性:能保证算法在有限时间找到解,能在没有可行规划时报告错误

**图和树**:将C空间表示成一个图,由N个节点和δ条边组成,每条边连接两个节点. 节点表示位形或状态, 边表示不穿透障碍物的情况下从n1到n2的能力
树是没有循环, 每个节点只有一个父节点的有向图.

### A*算法
A*算法通过f(n) = g(n) + h(n)计算每个函数的优先级，g(n)是节点n距起点的代价，h(n)是距终点的预计代价，优先选取f(n)最小的节点进行遍历。open_set表示待遍历节点，close_set表示已遍历节点。

**步骤：**
```
创建开启列表、关闭列表
将起始点加入开放列表中
弹出开启列表的第一个节点，将该元素作为当前节点
while(当前节点不为终点时)：	
	获取并处理当前节点的周围可通过的节点，
		为这些节点设置G值、H值，
		添加当前节点为这些可通过节点的父节点
	遍历当前节点的周围节点
		if(该节点可通过且不在关闭列表):
			if(该节点在开启列表):
				根据 估价函数F(n)进行比较
				if(开启列表的节点的估价函数大于该节点的估价函数):
					将开启列表的节点进行覆盖
			else:
				将该节点加入开启列表
	将当前节点添加到关闭列表中
	对开启列表进行排序
	当前节点<-获得开启列表的第一个元素
创建一个路径结果集
while(当前节点的父节点不为空):
	获得当前节点的索引，存入路径结果集中
	当前节点<-当前节点的父节点
返回路径结果集
结束
```